% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/multipartiteBM.R
\name{multipartiteBM}
\alias{multipartiteBM}
\title{Model selection and parameter estimation of MBM}
\usage{
multipartiteBM(
  list_Net,
  v_distrib = NULL,
  namesFG = NULL,
  v_Kmin = 1,
  v_Kmax = 10,
  v_Kinit = NULL,
  initBM = TRUE,
  save = FALSE,
  verbose = TRUE,
  nbCores = NULL,
  maxiterVE = NULL,
  maxiterVEM = NULL
)
}
\arguments{
\item{list_Net}{a list of networks (defined via the function defineNetwork) i.e. a multipartite network}

\item{v_distrib}{an optional vector of characters of length the number of networks and specifying the distribution used in each network (possible values \code{bernoulli,poisson,gaussian,laplace})}

\item{namesFG}{an optional vector of  characters containing the names of functional groups (FG) (If Specified, must correspond to the  names in \code{list_Net})}

\item{v_Kmin}{an optional vector of integers, specifying the minimal number of blocks per functional group (must be provided in the same order as in \code{namesFG}).
v_Kmin may be a single value (same minimal number of blocks for all the FGs) or a vector with size equal to the number of FGs.
Default value  \code{= 1}.}

\item{v_Kmax}{an optional vector of integers specifying the maximal number of blocks per functional group provided in the same order as in \code{namesFG}.
v_Kmax may be a single value (same maximal number of blocks for all the FGs) or a vector with size equal to the number of FGs.
Default value  \code{= 10}.}

\item{v_Kinit}{an optional vector of integers specifying initial numbers of blocks per FG provided in the same order as in \code{namesFG}.
if \code{v_Kinit} is not specified, then   \code{v_Kinit = v_Kmin}}

\item{initBM}{an optional boolean. If initBM = TRUE  an aditional initialisation is done using simple LBM or SBM on each network separatly.
Default value  \code{= TRUE}}

\item{save}{an optional boolean. If TRUE  save the estimated parameters for intermediate visited models. Otherwise, only the better model (in ICL sense) is the ouput. Default value \code{= FALSE}.}

\item{verbose}{an optional boolean. If  TRUE, display the current step of the search algorithm}

\item{nbCores}{an optional integer specifying the number or cores used for the estimation. Not parallelized on windows. If \code{ncores = NULL}, then half of the cores are used.}

\item{maxiterVE}{an optional integer  specifying the maximum number of iterations in the VE step of the VEM algorithm. If NULL then default value  \code{= 1000}}

\item{maxiterVEM}{an optional integer  specifying the maximum number of iterations of the VEM algorithm. If NULL then default value Default value  \code{= 1000}}
}
\value{
a list of estimated parameters for the different models ordered by decreasing ICL. If save \code{= FALSE}, the length is of length 1 (only the better model is returned).
\describe{
  \item{\code{fittedModel}}{contains the results of the inference. \code{res$fittedModel[[1]]}  is a list with fields
  \describe{
  \item{\code{paramEstim}}{a MBMfit object.}
  \item{\code{ICL}}{the penalized likelihood criterion ICL.}
  \item{\code{vJ}}{the sequence of the varational bound of the likelihood through iterations of the VEM.}
  \item{\code{convergence}}{TRUE if the VEM reached convergence.}
  }
  }
  \item{\code{list_Net}}{ contains the data.}
}
}
\description{
Select the number of blocks and identify the blocks per functional group using a variational EM algorithm
}
\details{
The function \code{multipartiteBM} selects the better numbers of blocks in each FG (with a penalized likelihood criterion). The model selection is performed with a forward backward strategy and the likelihood of each model is maximized with a variational EM).
}
\examples{
v_K <- c(3,2,2)
n_FG <- 3
list_pi <- vector("list", 3);
list_pi[[1]] <- c(0.4,0.3,0.3); list_pi[[2]] <- c(0.6,0.4); list_pi[[3]]  <- c(0.6,0.4)
E  = rbind(c(1,2),c(2,3),c(2,2))
v_distrib <- c('bernoulli','poisson','poisson')
typeInter <- c( "inc", "inc"  ,  "adj" )
list_theta <- list()
list_theta[[1]] <- matrix(rbeta(v_K[E[1,1]] * v_K[E[1,2]],1.5,1.5 ),nrow = v_K[E[1,1]], ncol = v_K[E[1,2]])
list_theta[[2]] <- matrix(rgamma(v_K[E[2,1]] * v_K[E[2,2]],7.5,1 ),nrow = v_K[E[2,1]], ncol = v_K[E[2,2]])
list_theta[[3]] <- matrix(rgamma(v_K[E[3,1]] * v_K[E[3,2]],7.5,1 ),nrow = v_K[E[3,1]], ncol = v_K[E[3,2]])
list_theta[[3]] <- 0.5*(list_theta[[3]] + t(list_theta[[3]])) # symetrisation for network 3
v_NQ = c(100,50,40)
dataSim <-  rMBM(v_NQ ,E , typeInter, v_distrib, list_pi, list_theta, seed=NULL, namesFG= c('A','B','D'),keepClassif = FALSE)
list_Net <- dataSim$list_Net
res <- multipartiteBM(list_Net, v_distrib = c("bernoulli","poisson","poisson"))
}
